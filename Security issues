[PV204] Security Technologies
KeePassNFC applet
3. Security Analysis


Sensitive values protected
Offline: the MP of the user database (as AES key) and the internal RSA key.
During usage: unencrypted blocks of the database and the transaction AES key.

Cryptographic algorithms and protocols used
There are 3 keys that are used in the applet:
Card Key: this will be public-private 2048b-RSA key pair generated, among which the public key will be used by the user for encryption of password key and transaction key during communication.
Password Key: this key is the symmetric AES-128 key used for decryption of KeePass database, with the IV parameter given by the user during every transaction.
Transaction Key: this key is a temporary symmetric AES-128 key generated by the user for every transaction (database decryption) and will be used by the card to encrypt the database while answering to each decrypt block request, with the IV parameter given by the user.
KeePassNFC applet makes use of three ciphers:
RSA_PKCS1 with the Card Key for decrypting the initial communications from the user. Probably chosen for its wide availability in smartcards.
AES-128 in CBC mode without padding in both the ciphers for:
decrypting the blocks of the database with the Password Key;
encrypting the decrypted block with the Transaction Key before sending to user.
No pre-existent protocol is used. The applet expects the user to follow this series of operations:
Before everything, the user should call (0x75) to let the applet generate its key pair, and then get the public key (0x70).
To set a new password key, the user must encrypt that key with the card public key, send it to the card with Write To Scratch (0x76), then call (0x71) to let the applet decrypt it and save it.
To decrypt the database, the user is expected to:
Write To Scratch (0x76) the transaction key encrypted with the card public key;
Prepare Decryption (0x72) sending the IV parameters for the ciphers of password and transaction, during which the applet decrypts also the Transaction Key;
Use Decrypt Block (0x73) for each piece of the database, setting the P1 of the last one with the value 0x80. Each response will contain the corresponding block of database encrypted with the Transaction Key.

State model of the applet

The applet does NOT manage in any way the internal states. We forward to Appendix A for complete details about the possible states of the applet.


Relevant attacker models
In this section we will evaluate directly the attack surface relative to the applet. For more details about the best security practises, we forward to Appendix B.
Two easy attacker models can perform a Denial of Service, changing the key pair in the card calling Generate Card Key (0x75), or getting the card public key (0x70) and substituting the Password Key (0x76 - 0x71).
A different attacker could implement a MITM attack to substitute the public key given to the user to one controlled by himself, and continue mediating between the card and the user, now being able to read each communication in clear.
If access to the card is gained by the attacker during the generation of card key pair, a possible timing attack could be implemented, also during the decryption of user communication, since the algorithm used is weak to the padding oracle attack. This could lead the attacker to decrypt the communication of the password key (if logged in any way).
With a smartcard that is already set up, sending a Decrypt Block with a legitimate precedent behaviour, then sending a Get Public Key (0x70) with offset != 0, the corresponding bytes of the decrypted block are sent to the user in plaintext. Thus, all bytes of the decrypted block are leakable except for the first one. This can be practically done if attacker can simply forge commands during user session (~malware). The user cannot notice the attack (maybe just some delay).



